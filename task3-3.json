{"editor":{"base":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace; //a_Position\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace; //a_Normal\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\nvarying vec4 v_Color; \n\n//main program for each vertex\nvoid main() {\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  gl_Position = pMatrix * vertex_camSpace;\n  v_Color = vec4(0.2, 0.0, 0.0, 1.0);\n  v_Normal = vec3(vMatrix * mMatrix * vec4(normal_worldSpace, 0.0));\n  v_Position = vec3(vertex_camSpace);\n}","isLinked":true},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\nuniform vec3 u_LightPos;\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\nvarying vec4 v_Color; \n\n//main program for each fragment = pixel candidate\nvoid main() {\n  float distance = length(u_LightPos - v_Position);\n  vec3 lightVector = u_LightPos - v_Position;\n\n  float intensity = dot(lightVector / distance, v_Normal / length(v_Normal));\n  vec4 toon = vec4(1, 0, 0, 0);\n  if (intensity > 0.98) {\n    toon = vec4(0.8, 0.8, 0.8, 1.0);\n  } else if (intensity > 0.5) {\n    toon = vec4(0.8, 0.4, 0.4, 1.0);\n  } else if (intensity > 0.25) {\n    toon = vec4(0.6, 0.2, 0.2, 1.0);\n  } else {\n    toon = vec4(0.1, 0.1, 0.1, 1.0);\n  }\n  gl_FragColor = toon; \n}","isLinked":true}},"R2T":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}","isLinked":true},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}","isLinked":true}}},"camera":{"position":[0,0,37],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWireframe":false},"uniforms":{"base":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"u_LightPos":{"attachment":"Camera Target"}}},"R2T":{"value":{"textureRendered":{"attachment":"Base Pass color"}}}}}