{"editor":{"base":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\n//main program for each vertex\nvoid main() {\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  gl_Position = pMatrix * vertex_camSpace;\n}","isLinked":true},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","isLinked":true}},"R2T":{"vertex":{"source":"attribute vec4 vertex_worldSpace;\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\nvarying vec3 origin;\nvarying vec3 dir;\nvoid main() {\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n                           vertex_worldSpace.y*orthographicFOV,\n                           0);\n    dir_camSpace = vec3(0, 0, -1);\n  }\n  else { // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n                        vertex_worldSpace.y,\n                        -1.0/tan(radians(perspectiveFOV)));\n}\n  origin = cameraPosition + cameraRotation*origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n  gl_Position = vertex_worldSpace;\n}","isLinked":true},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\nvarying vec3 origin, dir;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nuniform vec3 u_LightPos;\n\nstruct Sphere\n{\n  vec3 centre;\n  float radius;\n  vec3 colour;\n};\n\nstruct Plane\n{\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n};\n\nconst int N = 6;\nconst int depth = 42;\nSphere sphere[N];\nPlane plane;\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n};\n\nstruct Intersection\n{\n  float mu; \n  vec3 point;    \n  vec3 normal;  \n  int hit;\n  vec3 colour;\n};\n\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection intersect){\n  float v = dot(ray.dir, pl.normal);\n  float checker_width = 0.3;\n  if(v <= 0.0){\n    float mu = -dot((ray.origin - pl.point), pl.normal) / v;\n    if((mu > 0.0) && (mu < intersect.mu || intersect.mu < 0.)){\n      intersect.hit = 1;\n      intersect.mu = mu;\n      intersect.normal = pl.normal;\n\n      vec3 p = ray.origin * mu * ray.dir;\n      intersect.point = p;\n\n      if ((int(mod((floor(intersect.point.z / checker_width)), 2.0)) ==\n            (int(mod((floor(intersect.point.x / checker_width)), 2.0))))) {\n          intersect.colour = pl.colour;\n      } else {\n          intersect.colour = vec3(1.0 - pl.colour.x, 1.0 - pl.colour.y, 1.0 - pl.colour.z);\n      }\n    }\n  }\n}\n\nvoid sphere_intersect(Sphere sphere, Ray ray, inout Intersection intersect)\n{\n  float a = pow(length(ray.dir), 2.0);\n  float b = 2.0 * dot(ray.dir, (ray.origin - sphere.centre));\n  float c = pow(length(ray.origin - sphere.centre), 2.0) - pow(sphere.radius, 2.0);\n\n  float disc = pow(b, 2.0) - 4.0 * a * c;\n  if (disc > 0.0) {\n\n    float x1 = (-b + sqrt(disc)) / (2.0 * a);\n    float x2 = (-b - sqrt(disc)) / (2.0 * a);\n\n    float x = x2 > 0.0 && x1 > 0.0 ? min(x1, x2) : max(x1, x2);\n\n    if (x > 0.0 && (x < intersect.mu || intersect.mu < 0.0)) {\n      intersect.point = ray.origin + x * ray.dir;\n      intersect.normal = normalize(intersect.point - sphere.centre);\n      intersect.colour = sphere.colour;\n      intersect.mu = x;\n    }\n  }\n}\n\nvec3 shadow(in Intersection intersect){\n  vec4 colour = vec4(0, 0, 0,1);\n  \n  Ray shadowRay;\n  shadowRay.origin = intersect.point;\n  shadowRay.dir = normalize(u_LightPos - shadowRay.origin);\n  shadowRay.origin += shadowRay.dir * 0.001;\n\n  Intersection shadowI;\n  shadowI.mu = -1.0;\n\n  for(int i = 0; i < N; i++){\n    sphere_intersect(sphere[i], shadowRay, shadowI);\n  }\n  plane_intersect(plane, shadowRay, shadowI);\n \n  if ((shadowI.mu != -1.0 && shadowI.mu < length(u_LightPos - shadowRay.origin)) == false){\n    vec3 lightVector = u_LightPos - intersect.point;\n    \n    float d = length(lightVector);\n    float attenuation = 100.0 / (d * d);\n    \n    lightVector = normalize(lightVector);\n    vec3 reflV = reflect(lightVector, intersect.normal);\n    vec4 shadow = attenuation * vec4(intersect.colour, 1) * max(dot(intersect.normal, lightVector), 0.0);\n    colour += shadow;\n  }\n  return colour.xyz;\n}\n\n//main program for each fragment of the render quad\nvoid main() {\n\n  sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n  sphere[0].radius = 1.5;\n  sphere[0].colour = vec3(0.8,0.8,0.8);\n  sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n  sphere[1].radius = 0.6;\n  sphere[1].colour = vec3(0.3,0.8,0.3);\n  sphere[2].centre = vec3(1.0, 0.7, -2.2);\n  sphere[2].radius = 0.8;\n  sphere[2].colour = vec3(0.3,0.8,0.8);\n  sphere[3].centre = vec3(0.7, -0.3, -1.2);\n  sphere[3].radius = 0.2;\n  sphere[3].colour = vec3(0.8,0.8,0.3);\n  sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n  sphere[4].radius = 0.2;\n  sphere[4].colour = vec3(0.8,0.3,0.3);\n  sphere[5].centre = vec3(0.2, -0.2, -1.2);\n  sphere[5].radius = 0.3;\n  sphere[5].colour = vec3(0.8,0.3,0.8);\n  plane.point = vec3(0,-0.5, 0);\n  plane.normal = vec3(0, 1.0, 0);\n  plane.colour = vec3(1, 1, 1); \n\n  //ray tracing\n  Ray ray;\n  ray.origin = origin;\n  ray.dir = normalize(dir);\n\n  Intersection intersect;\n    intersect.hit = 0;\n    intersect.mu = -1.0;\n    intersect.normal = intersect.point = intersect.colour = vec3(0, 0, 0);\n    \n    const float refl = 0.4;\n    vec4 colour = vec4(0, 0, 0, 1);\n\n    for(int n = 0; n < depth; n++){\n\n      for(int i = 0; i < N; i++){\n        sphere_intersect(sphere[i], ray, intersect);\n      }\n      plane_intersect(plane, ray, intersect);\n\n      if (intersect.mu > 0.0){\n        colour.rgb += pow(refl, (float(n))) * shadow(intersect);\n        intersect.colour = vec3(0, 0, 0);\n        intersect.mu = -1.0;\n\n        Ray reflRay;\n        reflRay.origin = intersect.point;\n        reflRay.dir = normalize(ray.dir - dot(2. * ray.dir, intersect.normal) * intersect.normal);\n        reflRay.origin += reflRay.dir * 0.001;\n        ray = reflRay;\n      }\n    }\n    gl_FragColor = colour;\n}","isLinked":true}}},"camera":{"position":[0.3366467283512837,0.33990451530715304,0.5525763104542283],"target":[0,1,-2],"nearClipping":0.001,"farClipping":10000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[6,4,3],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"uniforms":{"base":{"value":{"mMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"vMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"pMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}}},"R2T":{"value":{"canvasWidth":{"value":[1096]},"canvasHeight":{"value":[531]},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"textureRendered":{"value":{"TEXTURE_2D":"http://shaderlabweb.doc.ic.ac.uk/"}},"projectionMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"modelViewMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"u_LightPos":{"attachment":"Model Position"}}}}}